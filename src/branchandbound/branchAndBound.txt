Branch and bound é um paradigma de projeto de algoritmo geralmente usado para resolver problemas de otimização combinatória. 
Esses problemas são tipicamente exponenciais em termos de complexidade de tempo e podem exigir a exploração de todas as permutações possíveis no pior caso. 
Branch and Bound resolvem esses problemas com relativa rapidez.

Vamos usar o problema da mochila abaixo para entender o Branch and Bound.
" Dados duas matrizes de inteiros val [0..n-1] e wt [0..n-1] que representam valores e pesos associados a n itens, respectivamente. 
Descubra o subconjunto de valor máximo de val [] de forma que a soma dos pesos deste subconjunto seja menor ou igual à capacidade W da mochila. "

Existem diferentes abordagens para resolver o problema acima, porem, a solução Branch and Bound é o método mais adequado quando os pesos dos itens não são inteiros.

Como encontrar o limite para cada nó da mochila ?
A ideia é usar o fato de que a abordagem Greedy fornece a melhor solução para o problema da mochila fracionária.
Para verificar se um determinado nó pode nos dar uma solução melhor ou não, calculamos a solução ótima (por meio do nó) usando a abordagem Greedy. 
Se a solução computada pela abordagem Greedy em si é mais do que a melhor até agora, então não podemos obter uma solução melhor por meio do nó.

Passo a passo do algoritmo:

- Classificar todos os itens em ordem decrescente de razão de valor por unidade de peso para que um limite superior possa ser calculado usando o Greedy Approach.
- Inicializar o lucro máximo, maxProfit = 0
- Criar uma fila vazia, Q.
- Criar um nó fictício da árvore de decisão e enfileire-o em Q. O lucro e o peso do nó fictício são 0.

- Fazer o seguinte enquanto Q não estiver vazio: 
  - Extrair um item de Q. Deixar o item extraído ser u.
  - Calcular o lucro do nó do próximo nível. Se o lucro for maior que maxProfit, atualizar o maxProfit.
  - Limite de cálculo do nó do próximo nível. Se o limite for maior do que maxProfit, adicione o nó do próximo nível a Q.

- Considerar o caso em que o nó do próximo nível não é considerado como parte da solução e adicione um nó à fila com o nível seguinte, mas peso e lucro sem considerar os nós do próximo nível. 

A seguir está a implementação em C ++ da ideia acima. 
